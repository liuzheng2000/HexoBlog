---
title: 021/12/6 理想汽车一面
abbrlink: 4253828478
date: 2021-12-09 10:42:03
tags: 面试
categories: 面试
description: 理想汽车一面情况
---
# 2021/12/6   理想汽车一面（面试官超级好）

大概问题如下  总流程 32分钟

首先  自我介绍  说明来意

### 1 谈一谈 你在大学生涯中  学习到的专业科与比较重要的项目

答：我在大学生涯中，我结合老师的讲解，自主学习了深入理解计算机系统，这本书对我影响很大，我从中清楚的认知到了有关于计算机的理解，认识到了操作系统 计算机网络等等

项目方面：我个人比较满意的是我的一个机器人框架的项目 于PicqBotX框架（By hykilpikonna 小桂）与 酷Q HTTP 插件二次开发完成，实现定制化开发。在其认知的基础上，它的开发方式是对于客户进行定制化开发，实现了不同的 对接其原本类的同时，扩展自己的方法，后续也在相应的版本中增添了自己的开发，增添了发送图片等API

### 2 你在简历中说到学习过计算机网络，那请你简单的谈一谈三次握手，四次握手（这里面试官可能说错了） 最后只说明了三次握手

   1、第一次握手：客户端给服务器发送一个 SYN 报文。

   2、第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。

   3、第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。

   4、服务器收到 ACK 报文之后，三次握手建立完成。

 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
     第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
     第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

   因此，需要三次握手才能确认双方的接收与发送能力是否正常。

（我基本上只答出来上面的）  下面是其他人的见解

> 因为三次握手的过程中，双方是由很多状态的改变的，而这些状态，也是面试官可能会问的点。所以我觉得在回答三次握手的时候，我们应该要描述的详细一点，而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：
>
> 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后
> 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。
>
> 2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号  ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD  的状态。
>
> 3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
>
> 4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。
>
> ![img](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/1937992-20200601224438472-1267725684.png?x-oss-process=style/qingyun)
>
> Ps:(1)SYN=1 表示该报文不携带数据，但消耗一个序号 seq=x，seq=x是客户端的初始化序列号，因为tcp是面向字节流的
> (2)SYN=1 表示该报文不携带数据，但消耗一个序号 seq=y，seq=y是服务器的初始化序列号，ACK=1是一个确认号
> ack=x+1，表示服务器下次接收到的序号希望是x+1。然后服务器进入到SYN-RCVD等待的状态
> (3)ACK=1是一个确认号，seq=x+1是上一次服务器回应的序号要求，ack=y+1表示客户下一次接收到的序号希望是y+1
>
> **三次握手的作用**
>
> 三次握手的作用也是有好多的，多记住几个，保证不亏。例如：
> 1、确认双方的接受能力、发送能力是否正常。
> 2、指定自己的初始化序列号，为后面的可靠传送做准备。
> 3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。
>
> 单单这样还不足以应付三次握手，面试官可能还会问一些其他的问题，例如：
> 1、（ISN）是固定的吗？
>
> 三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。
>
> 如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。
> 2、什么是半连接队列
>
> ​    服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD  状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。
>
> 这里在补充一点关于SYN-ACK  重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s,  2s, 4s, 8s, …
>
> 3、三次握手过程中可以携带数据吗
>
> 很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。
>
> 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN  报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。
> 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。
>
> ![img](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/1937992-20200601224627387-14281279.png?x-oss-process=style/qingyun)
>
> 当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端；
> 但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手；
> 但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器；
> 所以要进行3次握手

四次挥手 我并未答出  本文也引入答案

> 1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。
>
> 2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。
>
> 3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
>
> 4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于  TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
>
> 5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
>
> ![img](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/1937992-20200601224737314-796511323.png?x-oss-process=style/qingyun)
>
> 这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK  报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送  ACK 报文。
> 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

### 3我看你的简历中存在学习过Mysql引擎，那么请你说明一下Mysql引擎

答：Mysql常用两种引擎 **InnoDB存储引擎**  和**MyISAM存储引擎**引擎

#### 问：MyISAM引擎和InnoDB引擎 ，他们在使用 

```sql
select count(*) form Table
```

哪一个更快一些

答：MyISAM 更快 （这里解释的化我引用菜鸟教程更加直观）PS:我回答出来了

![image-20211206201137129](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/image-20211206201137129.png?x-oss-process=style/qingyun)

#### 问：MyISAM与InnoDB的使用场景

（我回答的是） select的较多场景下，引擎应该使用MyISAM，MyISAM引擎更加的适用于查询操作，它在查询过程中，有着更高的并发处理能力，可以较快的适用于查询操作，而其，它本身不支持事务，如果将其用于Insert 、 Update 则容易发生冲突

这样的原因也是用于为什么Insert 、 Update 选择InnoDB

![image-20211206201814999](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/image-20211206201814999.png?x-oss-process=style/qingyun)

#### 问：既然你提到了事务，那么事务的实现方式有两种，Spring事务及Mysql事务，那么你在项目中使用的是那种方式

（我并不太清楚使用的是那种方式，于是说明了我如何使用事务）

一：我使用事务的作用是在项目中，我可能会将插入、修改、查找等多个操作形成一个事务，那么我在运行过程中，如果出现意外情况，我需要将事务进行回滚，我会在测试过程中，在事务执行过程中，强制发生异常停止事务，依次来查看是否进行了回滚，来判断是否发生了事务。

#### 问：既然讲到了异常与事务，那么请你说明一下事务中的脏读与幻读是什么情况

答：假如，我开启了两个客户端，一个修改完数据，但未提交的过程中，另一个客户端读取了这个数据，于是形成了脏读

假如，我在读取过程中，读取了第一遍数据过程中，有一个客户端修改了数据，第二遍读取的时候，前面结果不一致，便形成了幻读

脏读(Read Uncommitted)

> 通俗的讲，一个事务在处理过程中读取了另外一个事务未提交的数据。(你都还没提交，我就读到了你刚操作的数据，万一你回滚了怎么办，你说这脏不脏。)
>
> 举例(事务B未提交，事务A却读到了事务B未提交的数据)：
>
> 幻读: 对于两个事务T1、T2，T1从表中读取数据，然后T2进行了INSERT操作并提交，当T1'再次读取的时候，结果不一致的情况发生。

PS：虽然没问隔离级别，但还是加上

![image-20211206203318762](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/image-20211206203318762.png?x-oss-process=style/qingyun)

### 4 看你项目上有关于SpringCloud 谈一谈你的理解

答：这里的，我是明说的，我确实学习过SpringCloud系列，但是未完整的搭建过一个SpringCloud项目，所以这里没详细谈，但还是问了下

#### 问：你说一个你知道的Cloud组件,它的用法和作用（大家可以尝试自己去尝试自主解答）

答：我回答的是网关，后面去解释了Nacos 了，不过确实不是特别好，就不说明了

### 5你使用过Redis集群，说一下你使用的场景吧

答：我是在搭建QQ机器人那个项目中实现的，就是将请求抽奖的时间限制，依据Redis的时间过期机制，来判断用户是否连续请求。防止同一用户一直请求。

#### 问：那你储存的格式类型是List还是String

答：应该是String吧（题主其实很久没接触过Redis了）

那再本文中复习一下Redis的数据类型，和适用场景吧

```
string 字符串（可以为整形、浮点型和字符串，统称为元素） 
 list 列表（实现队列,元素不唯一，先入先出原则） 
 set 集合（各不相同的元素） 
 hash hash散列值（hash的key必须是唯一的） 
 sort set 有序集合
```

> Hash（哈希）
>
> Redis hash 是一个键值(key=>value)对集合。
>
> Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。



> List（列表）
>
> Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。

>  Set（集合）
>
>  Redis 的 Set 是 string 类型的无序集合。
>
>  集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

> zset(sorted set：有序集合)
>
> Redis  zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
>
> 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
>
> zset的成员是唯一的,但分数(score)却可以重复。

![image-20211206205220753](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/image-20211206205220753.png?x-oss-process=style/qingyun)

#### 问：场景题  使用Redis 搭建附近的人

答：题主不太清楚，回来面试官给说了，叫我去了解  geo（大家后续可以去了解）

### 5算法题（未手撕，仅提供思路）

![67cda4adf7f8cfce37a6e8fe00b18eb](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/67cda4adf7f8cfce37a6e8fe00b18eb.png?x-oss-process=style/qingyun)

![ee66fdc5acc905725f101056533d728](https://qingyun-test.oss-cn-hangzhou.aliyuncs.com/img/ee66fdc5acc905725f101056533d728.png?x-oss-process=style/qingyun)

一眼看出来，可以层序遍历，合并两个二叉树

（当然，这题可以扩展，就不详谈了）

### 6Vue（掌握程度）

可以照葫芦画瓢，搭建一个项目

### 7杂谈

问：说一下自己的技术池

答：Spring Redis Mysql Docker maven git   SSL  DNS解析 FTP服务器搭建  Vue等等吧

## 问：你有什么想问我的吗？（个人认为问了一个很重要的问题）

（题主）问:在JAVA的学习过程中，如何去深度理解自己所学的，如何将java的底层与那种API的调用联系起来，不仅仅想知道可以这样用的同时，为什么可以这样用？该如何去阅读源码

（面试官）答：其实，我自己也是在这样子学习，不能够说出明确的答复，我们在学习过程中，遇到不懂得地方，不该仅仅得去查找博客解决问题，在接触他人得思考得同时，应该去自我思考，且一定要去看源码，只有源码的作者才可以说在他所写的应用是确定正确的。在遇到与他们观点冲突的同时，也不应该全盘否定自己的观点。

关于理想汽车的情况

```
很好的待遇
```

